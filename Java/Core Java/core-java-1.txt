What is deadlock. Give example with solutions. Tips to avoid dead lock ?
public class DeadLockDemo { 
public void method1() {
              synchronized (String.class) { 
                System.out.println("Aquired lock on String.class object");
                    synchronized (Integer.class) { 
                       System.out.println("Aquired lock on Integer.class object"); 
                    } } } 

public void method2() {
              synchronized (Integer.class)  { 
                  System.out.println("Aquired lock on Integer.class object"); 
                        synchronized (String.class) {
                            System.out.println("Aquired lock on String.class object"); 
                            } } } }

If method1() and method2() both will be called by two or many threads , 
there is a good chance of deadlock because if thread 1 acquires lock on Sting object while executing method1() 
and thread 2 acquires lock on Integer object while executing method2() both will be waiting for each other to release lock on Integer 
and String to proceed further which will never happen.
Solution : By avoiding circular wait with no preemption.
public void method1() {
              synchronized (Integer.class) { 
                       System.out.println("Aquired lock on Integer.class object"); 
                  synchronized (String.class) { 
                        System.out.println("Aquired lock on String.class object");
                    } } } 

public void method2() {
              synchronized (Integer.class)  { 
                  System.out.println("Aquired lock on Integer.class object"); 
                        synchronized (String.class) {
                            System.out.println("Aquired lock on String.class object"); 
                            } } } }
Tips to prevent deadlocks :
Avoid Nested Locks : This is the most common reason for deadlock. Avoid locking another resource if you already hold one.
It is almost impossible to get deadlock if you are working with only one object lock.
Avoid Unnecessary Locks
Use thread join()
Lock only what is required. Like lock particular field of object instead of locking whole object if it serves your purpose.
If you need to have multiple locks in your code, make sure everyone always acquire them in the same order.
Encapsulate If you must, keep your locks local. Global locks can be really tricky.
Do as little as possible when you hold the lock.
don't hold several locks at once. If you do, always acquire the locks in the same order 

What is ThreadFactory ?
java.util.concurrent.ThreadFactory creates a new thread and has been introduced in JDK 5. ThreadFactory is an interface has a method that is newThread() 
public Thread newThread(Runable r)
ThreadFactory is Factory pattern used in
Its usage depends on your requirement. Suppose you want a particular functionality to always create Daemon threads
To have custom thread names for debugging purposes
To choose Thread Priority
To handle uncaught exceptions

Thread program to print even and odd numbers
public class PrintNumbers extends Thread {
volatile static int i = 1;
Object lock;

PrintNumbers(Object lock) {
    this.lock = lock;
}

public static void main(String ar[]) {
    Object obj = new Object();
    // This constructor is required for the identification of wait/notify
    // communication
    PrintNumbers odd = new PrintNumbers(obj);
    PrintNumbers even = new PrintNumbers(obj);
    odd.setName("Odd");
    even.setName("Even");
    odd.start();
    even.start();
}

@Override
public void run() {
    while (i <= 10) {
        if (i % 2 == 0 && Thread.currentThread().getName().equals("Even")) {
            synchronized (lock) {
                System.out.println(Thread.currentThread().getName() + " - "
                        + i);
                i++;
                try {
                    lock.wait();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }
        if (i % 2 == 1 && Thread.currentThread().getName().equals("Odd")) {
            synchronized (lock) {
                System.out.println(Thread.currentThread().getName() + " - "
                        + i);
                i++;
                lock.notify();
              }
           }
        }
    }
}

What is semaphore and mutex ?
Semaphores – Restrict the number of threads that can access a resource. Semaphore maintains a counter which keeps track of the number of resources available. When a process requests access to resource, semaphore checks the variable count and if it is less than total count then grants access and subsequently reduces the available count
acquire(): When a thread needs to access a resource, it acquires the permit from the Semaphore using acquire() method. If the permit is not available, it holds until one is available. 
release(): Once the thread is finished using resource, it needs to return the permit. Using release() method of Semaphore, thread releases the permit back to Semaphore. 
binary semaphore can have a value either 0 or 1. It means binary semaphore protect the access to a SINGLE shared resource, so the internal counter of the semaphore can only take the values 1 or 0.
When the maximum number of permits of Semaphore is greater than 1, then it is considered as counting Semaphore. Counting Semaphore is used to restrict the use of resources
Example, limit max 10 connections to access a file simultaneously.
Let’s say now Shopper has 3 identical Laptops and 3 identical keys. Semaphore is the number of free identical Laptop keys. The semaphore count – the count of keys – is set to 3 at beginning (all three Laptops are free), then the count value is decremented as Customer are coming in. If all Laptops are in use, i.e. there are no free keys left for Laptop, the semaphore count is 0. Now, when any of the customer returns the Laptop, semaphore is increased to 1 (one free key), and given to the next customer in the queue.
Consider an ATM cubicle with 4 ATMs, Semaphore can make sure only 4 people can access simultaneously.
public class SemaphoreTest {

	// max 4 people
	static Semaphore semaphore = new Semaphore(4);

	static class MyATMThread extends Thread {

		String name = "";

		MyATMThread(String name) {
			this.name = name;
		}

		public void run() {

			try {

				
				System.out.println(name + " : acquiring lock...");
				System.out.println(name + " : available Semaphore permits now: " 
								+ semaphore.availablePermits());
				
				semaphore.acquire();
				System.out.println(name + " : got the permit!");

				try {

					for (int i = 1; i <= 5; i++) {

						System.out.println(name + " : is performing operation " + i 
								+ ", available Semaphore permits : "
								+ semaphore.availablePermits());

						// sleep 1 second
						Thread.sleep(1000);

					}

				} finally {

					// calling release() after a successful acquire()
					System.out.println(name + " : releasing lock...");
					semaphore.release();
					System.out.println(name + " : available Semaphore permits now: " 
								+ semaphore.availablePermits());

				}

			} catch (InterruptedException e) {

				e.printStackTrace();

			}

		}
	}

	public static void main(String[] args) {

		System.out.println("Total available Semaphore permits : " 
				+ semaphore.availablePermits());
	
		MyATMThread t1 = new MyATMThread("A");
		t1.start();

		MyATMThread t2 = new MyATMThread("B");
		t2.start();

		MyATMThread t3 = new MyATMThread("C");
		t3.start();

		MyATMThread t4 = new MyATMThread("D");
		t4.start();

		MyATMThread t5 = new MyATMThread("E");
		t5.start();

		MyATMThread t6 = new MyATMThread("F");
		t6.start();

	}
}





